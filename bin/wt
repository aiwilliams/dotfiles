#!/usr/bin/env bash
# wt — Git worktree manager with per-worktree database isolation.
#
# Uses auto-incrementing wtN identifiers as stable keys for directories,
# databases, and ports. Branches are optional metadata.
#
# Usage:
#   wt create <branch>            Create worktree with auto-numbered ID on a branch
#   wt create --detach            Create worktree in detached HEAD state
#   wt checkout                   Pick a remote branch (yours) to check out as a worktree
#   wt remove [N|wtN]             Remove worktree + drop DBs (fzf picker if no arg)
#   wt list                       List all worktrees with status
#   wt switch                     Interactive worktree switcher (requires fzf)
#   wt db-backup [label]          Backup current worktree's databases
#   wt db-restore [timestamp]     Restore databases from a backup

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")" && pwd)"
LIB_DIR="$(cd "$SCRIPT_DIR/../lib" && pwd)"

# shellcheck source=../lib/postgres.sh
source "$LIB_DIR/postgres.sh"

# --------------------------------------------------------------------------
# Helpers
# --------------------------------------------------------------------------

# Get the main worktree directory for the current repo
main_worktree_dir() {
  git worktree list --porcelain | grep '^worktree ' | head -1 | sed 's/^worktree //'
}

# Get the repo base name (directory name of the main worktree)
repo_name() {
  basename "$(main_worktree_dir)"
}

# Get the .env file path within a worktree
env_file_for() {
  echo "$1/apps/platform/.env"
}

# Scan sibling directories matching <repo>-wt[0-9]* and return the lowest
# unused positive integer. Fills gaps: if wt1 and wt3 exist, returns 2.
next_worktree_number() {
  local main_dir
  main_dir=$(main_worktree_dir)
  local parent_dir
  parent_dir=$(dirname "$main_dir")
  local repo
  repo=$(repo_name)

  # Collect all in-use numbers
  local -a used=()
  for dir in "$parent_dir/${repo}"-wt[0-9]*; do
    [[ -d "$dir" ]] || continue
    local name
    name=$(basename "$dir")
    local num="${name#"${repo}-wt"}"
    if [[ "$num" =~ ^[0-9]+$ ]]; then
      used+=("$num")
    fi
  done

  # Find the lowest unused positive integer
  local n=1
  while true; do
    local found=false
    for u in "${used[@]+"${used[@]}"}"; do
      if [[ "$u" -eq "$n" ]]; then
        found=true
        break
      fi
    done
    if [[ "$found" == false ]]; then
      echo "$n"
      return
    fi
    ((n++))
  done
}

# Compute the worktree directory path for a given number
worktree_dir_for_number() {
  local n="$1"
  local main_dir
  main_dir=$(main_worktree_dir)
  echo "$(dirname "$main_dir")/$(repo_name)-wt${n}"
}

# Determine the worktree identifier (e.g. "wt1" or "main") for the current directory.
current_worktree_id() {
  local toplevel
  toplevel=$(git rev-parse --show-toplevel)
  local main_dir
  main_dir=$(main_worktree_dir)

  if [[ "$toplevel" == "$main_dir" ]]; then
    echo "main"
    return
  fi

  local repo dir_name
  repo=$(repo_name)
  dir_name=$(basename "$toplevel")
  if [[ "$dir_name" =~ ^${repo}-wt([0-9]+)$ ]]; then
    echo "wt${BASH_REMATCH[1]}"
    return
  fi

  echo -e "${RED}Cannot determine worktree ID for $toplevel${NC}" >&2
  return 1
}

# Compute port from worktree number: 3000 + N
compute_port() {
  local n="$1"
  local port=$((3000 + n))
  if [[ "$port" -gt 65535 ]]; then
    echo -e "${RED}Port ${port} exceeds 65535${NC}" >&2
    exit 1
  fi
  echo "$port"
}

# Update POSTGRES_*, PORT, NEXT_PUBLIC_HOST, and NEXT_PUBLIC_SITE_URL in a .env file.
# Delegates POSTGRES_* handling to pg_apply_env, then layers on PORT, host, and site URL.
write_env_vars() {
  local env_file="$1"
  local wt_identifier="$2"
  local port="$3"
  local host
  host=$(hostname)

  # Strip managed vars if the file exists (pg_apply_env handles POSTGRES_*)
  if [[ -f "$env_file" ]]; then
    local tmp
    tmp=$(mktemp)
    grep -v '^PORT=\|^NEXT_PUBLIC_HOST=\|^NEXT_PUBLIC_SITE_URL=' "$env_file" > "$tmp" || true
    sed -i -e :a -e '/^\n*$/{$d;N;ba' -e '}' "$tmp"
    echo "" >> "$tmp"
    echo "PORT=${port}" >> "$tmp"
    echo "NEXT_PUBLIC_HOST=${host}" >> "$tmp"
    echo "NEXT_PUBLIC_SITE_URL=https://${host}:${port}" >> "$tmp"
    mv "$tmp" "$env_file"
  else
    mkdir -p "$(dirname "$env_file")"
    {
      echo "PORT=${port}"
      echo "NEXT_PUBLIC_HOST=${host}"
      echo "NEXT_PUBLIC_SITE_URL=https://${host}:${port}"
    } > "$env_file"
  fi

  pg_apply_env "$env_file" "$wt_identifier"
}

# --------------------------------------------------------------------------
# Colors
# --------------------------------------------------------------------------

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BOLD='\033[1m'
NC='\033[0m'

# --------------------------------------------------------------------------
# Commands
# --------------------------------------------------------------------------

usage() {
  cat <<EOF
Usage: wt <command> [args]

Commands:
  create <branch>            Create worktree on a branch (or --detach for detached HEAD)
  checkout                   Pick a remote branch (yours) to check out as a worktree
  remove [N|wtN]             Remove worktree and drop DBs (interactive picker if no arg)
  list                       List all worktrees with ID, branch, port, and status
  switch                     Interactive worktree switcher (requires fzf)
  db-backup [label]          Backup current worktree's databases (optional label)
  db-restore [timestamp]     Restore databases from a backup (fzf picker if no arg)
  help                       Show detailed documentation
EOF
  exit 1
}

cmd_help() {
  cat <<'EOF'
wt — Git worktree manager with per-worktree database isolation.

OVERVIEW

  wt automates creating, managing, and removing git worktrees with isolated
  PostgreSQL databases and unique dev-server ports. Each worktree gets an
  auto-incrementing identifier (wt1, wt2, ...) that serves as the stable key
  for its directory, databases, and port. Gaps are filled: if wt1 and wt3
  exist, the next worktree gets wt2.

THE wtN NUMBERING SYSTEM

  Everything derives from the worktree number N:

    Directory   ../<repo>-wt<N>     e.g. ../myapp-wt1
    Databases   <repo>_wt<N>_*      e.g. myapp_wt1_dev, myapp_wt1_test
    Port        3000 + N            e.g. 3001 for wt1, 3002 for wt2
    .env        PORT, POSTGRES_*, NEXT_PUBLIC_HOST, NEXT_PUBLIC_SITE_URL are set automatically

COMMANDS

  wt create <branch>
  wt create --detach

    Create a new worktree with the next available wtN identifier. A branch
    name is required — the worktree checks out or creates that branch, copies
    .env from main, clones databases, and runs scripts/setup.sh if present.
    Use --detach for the rare case of a detached HEAD worktree.

    Examples:
      wt create my-feature   # worktree on branch my-feature
      wt create --detach     # detached worktree at next wtN

  wt checkout

    Interactive picker (requires gh + fzf) that lists your remote branches
    with open PRs that aren't already checked out as worktrees. Selecting a
    branch runs wt create --branch <name> for you.

  wt remove [N|wtN]

    Remove a worktree and drop its databases. Accepts a number (3) or
    identifier (wt3). With no argument, opens an fzf picker.

    Examples:
      wt remove 2     # remove wt2
      wt remove wt2   # same thing
      wt remove        # interactive picker

  wt list

    Show all worktrees with their ID, directory, branch, port, dirty status,
    and commit hash.

  wt switch

    Interactive fzf picker to select a worktree and print its path. Useful
    with cd: cd $(wt switch)

  wt help

    Show this documentation.

COMPANION TOOL: db-worktree

  db-worktree manages PostgreSQL databases independently of git worktrees.
  wt calls it automatically during create/remove, but you can use it directly
  for lower-level database operations.

  db-worktree subcommands:
    create <id>           Create empty DBs + user
    clone <id> [source]   Clone DBs from source (default: main)
    drop <id>             Drop DBs + user
    list                  List all worktree databases
    env <id>              Print .env connection vars
    status <id>           Show DB sizes, user, extensions
    init-main             Create main branch DBs (first-time setup)

  wt create calls db-worktree clone; wt remove calls db-worktree drop.

DATABASE BACKUP & RESTORE

  wt db-backup [label]

    Dump all databases for the current worktree using pg_dump (custom format).
    Backups are timestamped and stored under ~/.local/share/wt-backups/<id>/.
    An optional label (e.g. "before-migration") is saved alongside the backup
    for easy identification.

    Examples:
      wt db-backup                    # backup with timestamp only
      wt db-backup before-migration   # backup with a label

  wt db-restore [timestamp]

    Restore all databases for the current worktree from a previous backup.
    With no argument, opens an fzf picker to choose a backup. Accepts a
    timestamp directly to skip the picker. The target databases are dropped
    and recreated before restoring.

    Examples:
      wt db-restore                         # interactive picker
      wt db-restore 20260219-143000         # restore a specific backup
EOF
}

cmd_create() {
  local branch=""
  local detach=false

  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --detach)
        detach=true
        shift
        ;;
      -*)
        echo -e "${RED}Unknown option: $1${NC}"
        usage
        ;;
      *)
        if [[ -n "$branch" ]]; then
          echo -e "${RED}Unexpected argument: $1${NC}"
          usage
        fi
        branch="$1"
        shift
        ;;
    esac
  done

  if [[ -z "$branch" ]] && [[ "$detach" == false ]]; then
    echo -e "${RED}Error: branch name required${NC}"
    echo ""
    echo "Usage: wt create <branch>        Create worktree on a branch"
    echo "       wt create --detach        Create worktree in detached HEAD state"
    exit 1
  fi

  if [[ -n "$branch" ]] && [[ "$detach" == true ]]; then
    echo -e "${RED}Error: cannot specify both a branch and --detach${NC}"
    exit 1
  fi

  local n
  n=$(next_worktree_number)
  local wt_id="wt${n}"
  local wt_dir
  wt_dir=$(worktree_dir_for_number "$n")
  local port
  port=$(compute_port "$n")

  if [[ "$detach" == true ]]; then
    echo -e "${BOLD}Creating worktree ${wt_id} (detached)${NC}"
  else
    echo -e "${BOLD}Creating worktree ${wt_id} for branch '${branch}'${NC}"
  fi
  echo ""

  # Create git worktree
  echo -e "${GREEN}Git worktree:${NC} $wt_dir"
  if [[ "$detach" == true ]]; then
    git worktree add "$wt_dir" --detach
  else
    git fetch origin "$branch" 2>/dev/null || true
    git worktree add "$wt_dir" "$branch" 2>/dev/null \
      || git worktree add "$wt_dir" "origin/$branch" 2>/dev/null \
      || git worktree add "$wt_dir" -b "$branch"
  fi

  # Clone databases from main
  echo ""
  pg_clone_worktree_dbs "$wt_id"

  # Update .env with worktree-specific vars (setup.sh copies .env from main via post-checkout hook)
  local wt_env
  wt_env=$(env_file_for "$wt_dir")
  write_env_vars "$wt_env" "$wt_id" "$port"
  echo -e "${GREEN}Updated POSTGRES_*, PORT, NEXT_PUBLIC_HOST, NEXT_PUBLIC_SITE_URL in .env${NC}"

  # Track branch in Graphite if --branch was provided and gt is available
  if [[ -n "$branch" ]] && command -v gt &>/dev/null; then
    echo ""
    echo -e "${BOLD}Tracking branch in Graphite...${NC}"
    local pr_base=""
    if command -v gh &>/dev/null; then
      pr_base=$(gh pr view "$branch" --json baseRefName --jq '.baseRefName' 2>/dev/null) || true
    fi
    if [[ -n "${pr_base:-}" ]]; then
      echo -e "  PR targets: ${pr_base}"
      (cd "$wt_dir" && git rebase "origin/${pr_base}" 2>/dev/null; gt branch track --force --parent "$pr_base" 2>/dev/null) \
        && echo -e "${GREEN}Tracked in Graphite (parent: ${pr_base})${NC}" \
        || echo -e "${YELLOW}Graphite tracking skipped${NC}"
    else
      (cd "$wt_dir" && gt branch track --force 2>/dev/null) \
        && echo -e "${GREEN}Tracked in Graphite${NC}" \
        || echo -e "${YELLOW}Graphite tracking skipped (no PR found, used nearest ancestor)${NC}"
    fi
  fi

  echo ""
  echo -e "${BOLD}Ready!${NC} cd $wt_dir"
}

cmd_checkout() {
  if ! command -v gh &>/dev/null; then
    echo -e "${RED}gh CLI is required. Install it first.${NC}"
    exit 1
  fi

  if ! command -v fzf &>/dev/null; then
    echo -e "${RED}fzf is required for interactive selection.${NC}"
    exit 1
  fi

  # Verify gh authentication
  gh api user --jq '.login' 2>/dev/null > /dev/null || {
    echo -e "${RED}Not authenticated with gh. Run 'gh auth login' first.${NC}"
    exit 1
  }

  echo -e "${BOLD}Fetching your remote branches...${NC}"
  git fetch --prune origin > /dev/null 2>&1

  # Get branches already checked out in worktrees
  local wt_branches
  wt_branches=$(git worktree list --porcelain | awk '/^branch / { sub(/^refs\/heads\//, "", $2); print $2 }')

  # List remote branches excluding those already in a worktree and HEAD
  local branches
  branches=$(
    git for-each-ref \
      --sort=-committerdate \
      --format='%(refname:short)|%(authorname)|%(authoremail)|%(committerdate:relative)|%(subject)' \
      refs/remotes/origin/ \
    | grep -v '^origin/HEAD' \
    | while IFS='|' read -r ref _author _email date subject; do
        local branch="${ref#origin/}"

        # Skip branches already in a worktree
        if echo "$wt_branches" | grep -qx "$branch"; then
          continue
        fi

        echo "${branch}|${date}|${subject}"
      done
  )

  # Filter to branches owned by the GitHub user using gh pr list
  local pr_branches
  pr_branches=$(gh pr list --author "@me" --state all --limit 100 --json headRefName --jq '.[].headRefName' 2>/dev/null)

  # Build the selectable list: branches that have a PR by this user
  local selectable
  selectable=$(
    echo "$branches" | while IFS='|' read -r branch date subject; do
      [[ -z "$branch" ]] && continue
      if echo "$pr_branches" | grep -qx "$branch"; then
        printf "%-40s %-20s %s\n" "$branch" "$date" "$subject"
      fi
    done
  )

  if [[ -z "$selectable" ]]; then
    echo -e "${YELLOW}No remote branches found with your PRs that aren't already worktrees.${NC}"
    exit 0
  fi

  # Let user pick
  local selection
  selection=$(echo "$selectable" | fzf --prompt="Check out branch: " --header="BRANCH                                   UPDATED              SUBJECT") || exit 0

  local branch
  branch=$(echo "$selection" | awk '{print $1}')

  if [[ -z "$branch" ]]; then
    echo "No branch selected."
    exit 0
  fi

  echo ""
  cmd_create --branch "$branch"
}

cmd_remove() {
  local arg="${1:-}"
  local n=""

  if [[ -z "$arg" ]]; then
    # Interactive picker
    if ! command -v fzf &>/dev/null; then
      echo -e "${RED}fzf is required for interactive selection, or pass a worktree number.${NC}"
      exit 1
    fi

    local main_dir
    main_dir=$(main_worktree_dir)
    local repo
    repo=$(repo_name)

    # Build a list of wtN worktrees for the picker
    git worktree list --porcelain | awk '
      /^worktree / { wt = $2 }
      /^branch /   { branch = $2; sub(/^refs\/heads\//, "", branch) }
      /^$/ {
        if (wt != "") print wt "|" branch
        wt = ""; branch = ""
      }
    ' | while IFS='|' read -r wt_path branch; do
      local dir_name
      dir_name=$(basename "$wt_path")
      # Only show wtN worktrees, not main
      if [[ "$dir_name" =~ ^${repo}-wt([0-9]+)$ ]]; then
        local wt_num="${BASH_REMATCH[1]}"
        printf "wt%-4s %-40s %s\n" "$wt_num" "$wt_path" "${branch:-(detached)}"
      fi
    done > /tmp/wt_remove_list.$$ || true

    if [[ ! -s /tmp/wt_remove_list.$$ ]]; then
      echo -e "${YELLOW}No worktrees to remove.${NC}"
      rm -f /tmp/wt_remove_list.$$
      exit 0
    fi

    local selection
    selection=$(cat /tmp/wt_remove_list.$$ | fzf --prompt="Remove worktree: " --header="ID     DIRECTORY                                 BRANCH") || {
      rm -f /tmp/wt_remove_list.$$
      exit 0
    }
    rm -f /tmp/wt_remove_list.$$

    n=$(echo "$selection" | awk '{print $1}' | sed 's/^wt//')
  else
    # Parse arg: accept "3" or "wt3"
    n="${arg#wt}"
    if ! [[ "$n" =~ ^[0-9]+$ ]]; then
      echo -e "${RED}Invalid worktree identifier: ${arg}${NC}"
      echo "Usage: wt remove [N|wtN]"
      exit 1
    fi
  fi

  local wt_id="wt${n}"
  local wt_dir
  wt_dir=$(worktree_dir_for_number "$n")

  echo -e "${BOLD}Removing worktree ${wt_id}${NC}"
  echo ""

  # Remove git worktree
  if git worktree list --porcelain | grep -q "^worktree ${wt_dir}$"; then
    echo -e "${YELLOW}Removing worktree:${NC} $wt_dir"
    git worktree remove "$wt_dir" --force
  else
    echo "Worktree directory not found in git, skipping git worktree remove."
    if [[ -d "$wt_dir" ]]; then
      rm -rf "$wt_dir"
    fi
  fi

  # Drop databases and user
  echo ""
  pg_drop_worktree_dbs "$wt_id"

  echo ""
  echo -e "${BOLD}Done.${NC}"
}

cmd_list() {
  local main_dir
  main_dir=$(main_worktree_dir)
  local repo
  repo=$(repo_name)
  local home_dir="$HOME"

  {
    printf "ID\tDIRECTORY\tBRANCH\tPORT\tSTATUS\tCOMMIT\n"

    git worktree list --porcelain | awk -v main_dir="$main_dir" -v repo="$repo" -v home="$home_dir" '
      /^worktree / { wt = $2 }
      /^HEAD /     { commit = substr($2, 1, 7) }
      /^branch /   { branch = $2; sub(/^refs\/heads\//, "", branch) }
      /^detached/  { branch = "(detached)" }
      /^$/ {
        if (wt != "") {
          # Check for dirty state
          cmd = "git -C " wt " status --porcelain 2>/dev/null | head -1"
          cmd | getline dirty
          close(cmd)
          status = (dirty != "") ? "*" : ""

          dir_name = wt
          sub(/.*\//, "", dir_name)

          if (wt == main_dir) {
            id = "main"
            port = "3000"
          } else {
            # Check if this is a wtN-style worktree
            pattern = repo "-wt"
            if (index(dir_name, pattern) == 1) {
              num = substr(dir_name, length(pattern) + 1)
              if (num ~ /^[0-9]+$/) {
                id = "wt" num
                port = 3000 + num
              } else {
                id = "?"
                port = "?"
              }
            } else {
              id = "old"
              port = "?"
            }
          }

          # Abbreviate directory: replace $HOME with ~, shorten intermediate segments
          display_dir = wt
          if (index(display_dir, home) == 1) {
            display_dir = "~" substr(display_dir, length(home) + 1)
          }
          n = split(display_dir, parts, "/")
          result = parts[1]
          for (i = 2; i < n; i++) {
            result = result "/" substr(parts[i], 1, 1)
          }
          if (n > 1) result = result "/" parts[n]
          display_dir = result

          # Truncate long branch names
          max_branch = 30
          if (length(branch) > max_branch) {
            branch = substr(branch, 1, max_branch - 1) "…"
          }

          printf "%s\t%s\t%s\t%s\t%s\t%s\n", id, display_dir, branch, port, status, commit
        }
        wt = ""; commit = ""; branch = ""; dirty = ""
      }
    '
  } | column -t -s $'\t' | {
    IFS= read -r header
    echo -e "${BOLD}${header}${NC}"
    cat
  }
}

cmd_switch() {
  if ! command -v fzf &>/dev/null; then
    echo "fzf is required for interactive switching. Install it or use 'cd' directly." >&2
    echo "" >&2
    cmd_list >&2
    exit 1
  fi

  local selection
  selection=$(git worktree list | fzf --prompt="Switch to worktree: " | awk '{print $1}')

  if [[ -n "$selection" ]]; then
    echo "$selection"
  fi
}

cmd_db_backup() {
  local label="${1:-}"
  local wt_id
  wt_id=$(current_worktree_id)

  echo -e "${BOLD}Backing up databases for ${wt_id}${NC}"
  echo ""
  pg_backup_worktree_dbs "$wt_id" "$label"
}

cmd_db_restore() {
  local timestamp="${1:-}"
  local wt_id
  wt_id=$(current_worktree_id)
  local sanitized
  sanitized=$(pg_sanitize_branch_name "$wt_id")
  local backup_dir="${PG_BACKUP_DIR}/${sanitized}"

  if [[ ! -d "$backup_dir" ]]; then
    echo -e "${RED}No backups found for ${wt_id}${NC}"
    exit 1
  fi

  if [[ -z "$timestamp" ]]; then
    # Interactive picker
    if ! command -v fzf &>/dev/null; then
      echo -e "${RED}fzf is required for interactive selection, or pass a timestamp.${NC}"
      echo ""
      echo "Available backups:"
      pg_list_backups "$wt_id"
      exit 1
    fi

    local listing
    listing=$(pg_list_backups "$wt_id")
    if [[ -z "$listing" ]]; then
      echo -e "${RED}No backups found for ${wt_id}${NC}"
      exit 1
    fi

    local selection
    selection=$(echo "$listing" | fzf --prompt="Restore backup: " --tac) || exit 0
    timestamp=$(echo "$selection" | awk '{print $1}')
  fi

  local backup_subdir="${backup_dir}/${timestamp}"
  if [[ ! -d "$backup_subdir" ]]; then
    echo -e "${RED}Backup not found: ${backup_subdir}${NC}"
    exit 1
  fi

  echo -e "${BOLD}Restoring databases for ${wt_id} from ${timestamp}${NC}"
  echo ""
  pg_restore_worktree_dbs "$wt_id" "$backup_subdir"
}

# --- Main dispatch ---

# Ensure we're in a git repo
if ! git rev-parse --git-dir > /dev/null 2>&1; then
  echo "Error: not in a git repository."
  exit 1
fi

[[ $# -lt 1 ]] && { cmd_help; exit 0; }

command="$1"
shift

case "$command" in
  create)     cmd_create "$@" ;;
  checkout)   cmd_checkout ;;
  remove)     cmd_remove "$@" ;;
  list)       cmd_list ;;
  switch)     cmd_switch ;;
  db-backup)  cmd_db_backup "$@" ;;
  db-restore) cmd_db_restore "$@" ;;
  help)       cmd_help ;;
  *)          echo "Unknown command: $command"; usage ;;
esac
