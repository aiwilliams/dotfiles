#!/usr/bin/env bash
# wt — Git worktree manager with per-worktree database isolation.
#
# Uses auto-incrementing wtN identifiers as stable keys for directories,
# databases, and ports. Branches are optional metadata.
#
# Usage:
#   wt create <branch>            Create worktree with auto-numbered ID on a branch
#   wt create --detach            Create worktree in detached HEAD state
#   wt checkout                   Pick a remote branch (yours) to check out as a worktree
#   wt remove [N|wtN]             Remove worktree + drop DBs (fzf picker if no arg)
#   wt list                       List all worktrees with status
#   wt switch                     Interactive worktree switcher (requires fzf)

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")" && pwd)"
LIB_DIR="$(cd "$SCRIPT_DIR/../lib" && pwd)"

# shellcheck source=../lib/postgres.sh
source "$LIB_DIR/postgres.sh"

# --------------------------------------------------------------------------
# Helpers
# --------------------------------------------------------------------------

# Get the main worktree directory for the current repo
main_worktree_dir() {
  git worktree list --porcelain | grep '^worktree ' | head -1 | sed 's/^worktree //'
}

# Get the repo base name (directory name of the main worktree)
repo_name() {
  basename "$(main_worktree_dir)"
}

# Get the .env file path within a worktree
env_file_for() {
  echo "$1/apps/platform/.env"
}

# Scan sibling directories matching <repo>-wt[0-9]* and return the lowest
# unused positive integer. Fills gaps: if wt1 and wt3 exist, returns 2.
next_worktree_number() {
  local main_dir
  main_dir=$(main_worktree_dir)
  local parent_dir
  parent_dir=$(dirname "$main_dir")
  local repo
  repo=$(repo_name)

  # Collect all in-use numbers
  local -a used=()
  for dir in "$parent_dir/${repo}"-wt[0-9]*; do
    [[ -d "$dir" ]] || continue
    local name
    name=$(basename "$dir")
    local num="${name#"${repo}-wt"}"
    if [[ "$num" =~ ^[0-9]+$ ]]; then
      used+=("$num")
    fi
  done

  # Find the lowest unused positive integer
  local n=1
  while true; do
    local found=false
    for u in "${used[@]+"${used[@]}"}"; do
      if [[ "$u" -eq "$n" ]]; then
        found=true
        break
      fi
    done
    if [[ "$found" == false ]]; then
      echo "$n"
      return
    fi
    ((n++))
  done
}

# Compute the worktree directory path for a given number
worktree_dir_for_number() {
  local n="$1"
  local main_dir
  main_dir=$(main_worktree_dir)
  echo "$(dirname "$main_dir")/$(repo_name)-wt${n}"
}

# Compute port from worktree number: 3000 + N
compute_port() {
  local n="$1"
  local port=$((3000 + n))
  if [[ "$port" -gt 65535 ]]; then
    echo -e "${RED}Port ${port} exceeds 65535${NC}" >&2
    exit 1
  fi
  echo "$port"
}

# Update POSTGRES_*, PORT, and NEXT_PUBLIC_SITE_URL in a .env file.
# Delegates POSTGRES_* handling to pg_apply_env, then layers on PORT and site URL.
write_env_vars() {
  local env_file="$1"
  local wt_identifier="$2"
  local port="$3"

  # Strip PORT and NEXT_PUBLIC_SITE_URL if the file exists (pg_apply_env handles POSTGRES_*)
  if [[ -f "$env_file" ]]; then
    local tmp
    tmp=$(mktemp)
    grep -v '^PORT=\|^NEXT_PUBLIC_SITE_URL=' "$env_file" > "$tmp" || true
    sed -i -e :a -e '/^\n*$/{$d;N;ba' -e '}' "$tmp"
    echo "" >> "$tmp"
    echo "PORT=${port}" >> "$tmp"
    echo "NEXT_PUBLIC_SITE_URL=https://$(hostname):${port}" >> "$tmp"
    mv "$tmp" "$env_file"
  else
    mkdir -p "$(dirname "$env_file")"
    {
      echo "PORT=${port}"
      echo "NEXT_PUBLIC_SITE_URL=https://$(hostname):${port}"
    } > "$env_file"
  fi

  pg_apply_env "$env_file" "$wt_identifier"
}

# --------------------------------------------------------------------------
# Colors
# --------------------------------------------------------------------------

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BOLD='\033[1m'
NC='\033[0m'

# --------------------------------------------------------------------------
# Commands
# --------------------------------------------------------------------------

usage() {
  cat <<EOF
Usage: wt <command> [args]

Commands:
  create <branch>            Create worktree on a branch (or --detach for detached HEAD)
  checkout                   Pick a remote branch (yours) to check out as a worktree
  remove [N|wtN]             Remove worktree and drop DBs (interactive picker if no arg)
  list                       List all worktrees with ID, branch, port, and status
  switch                     Interactive worktree switcher (requires fzf)
  help                       Show detailed documentation
EOF
  exit 1
}

cmd_help() {
  cat <<'EOF'
wt — Git worktree manager with per-worktree database isolation.

OVERVIEW

  wt automates creating, managing, and removing git worktrees with isolated
  PostgreSQL databases and unique dev-server ports. Each worktree gets an
  auto-incrementing identifier (wt1, wt2, ...) that serves as the stable key
  for its directory, databases, and port. Gaps are filled: if wt1 and wt3
  exist, the next worktree gets wt2.

THE wtN NUMBERING SYSTEM

  Everything derives from the worktree number N:

    Directory   ../<repo>-wt<N>     e.g. ../myapp-wt1
    Databases   <repo>_wt<N>_*      e.g. myapp_wt1_dev, myapp_wt1_test
    Port        3000 + N            e.g. 3001 for wt1, 3002 for wt2
    .env        PORT, POSTGRES_*, NEXT_PUBLIC_SITE_URL are set automatically

COMMANDS

  wt create <branch>
  wt create --detach

    Create a new worktree with the next available wtN identifier. A branch
    name is required — the worktree checks out or creates that branch, copies
    .env from main, clones databases, and runs scripts/setup.sh if present.
    Use --detach for the rare case of a detached HEAD worktree.

    Examples:
      wt create my-feature   # worktree on branch my-feature
      wt create --detach     # detached worktree at next wtN

  wt checkout

    Interactive picker (requires gh + fzf) that lists your remote branches
    with open PRs that aren't already checked out as worktrees. Selecting a
    branch runs wt create --branch <name> for you.

  wt remove [N|wtN]

    Remove a worktree and drop its databases. Accepts a number (3) or
    identifier (wt3). With no argument, opens an fzf picker.

    Examples:
      wt remove 2     # remove wt2
      wt remove wt2   # same thing
      wt remove        # interactive picker

  wt list

    Show all worktrees with their ID, directory, branch, port, dirty status,
    and commit hash.

  wt switch

    Interactive fzf picker to select a worktree and print its path. Useful
    with cd: cd $(wt switch)

  wt help

    Show this documentation.

COMPANION TOOL: db-worktree

  db-worktree manages PostgreSQL databases independently of git worktrees.
  wt calls it automatically during create/remove, but you can use it directly
  for lower-level database operations.

  db-worktree subcommands:
    create <id>           Create empty DBs + user
    clone <id> [source]   Clone DBs from source (default: main)
    drop <id>             Drop DBs + user
    list                  List all worktree databases
    env <id>              Print .env connection vars
    status <id>           Show DB sizes, user, extensions
    init-main             Create main branch DBs (first-time setup)

  wt create calls db-worktree clone; wt remove calls db-worktree drop.
EOF
}

cmd_create() {
  local branch=""
  local detach=false

  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --detach)
        detach=true
        shift
        ;;
      -*)
        echo -e "${RED}Unknown option: $1${NC}"
        usage
        ;;
      *)
        if [[ -n "$branch" ]]; then
          echo -e "${RED}Unexpected argument: $1${NC}"
          usage
        fi
        branch="$1"
        shift
        ;;
    esac
  done

  if [[ -z "$branch" ]] && [[ "$detach" == false ]]; then
    echo -e "${RED}Error: branch name required${NC}"
    echo ""
    echo "Usage: wt create <branch>        Create worktree on a branch"
    echo "       wt create --detach        Create worktree in detached HEAD state"
    exit 1
  fi

  if [[ -n "$branch" ]] && [[ "$detach" == true ]]; then
    echo -e "${RED}Error: cannot specify both a branch and --detach${NC}"
    exit 1
  fi

  local n
  n=$(next_worktree_number)
  local wt_id="wt${n}"
  local wt_dir
  wt_dir=$(worktree_dir_for_number "$n")
  local port
  port=$(compute_port "$n")

  if [[ "$detach" == true ]]; then
    echo -e "${BOLD}Creating worktree ${wt_id} (detached)${NC}"
  else
    echo -e "${BOLD}Creating worktree ${wt_id} for branch '${branch}'${NC}"
  fi
  echo ""

  # Create git worktree
  echo -e "${GREEN}Git worktree:${NC} $wt_dir"
  if [[ "$detach" == true ]]; then
    git worktree add "$wt_dir" --detach
  else
    git fetch origin "$branch" 2>/dev/null || true
    git worktree add "$wt_dir" "$branch" 2>/dev/null \
      || git worktree add "$wt_dir" "origin/$branch" 2>/dev/null \
      || git worktree add "$wt_dir" -b "$branch"
  fi

  # Clone databases from main
  echo ""
  pg_clone_worktree_dbs "$wt_id"

  # Update .env with worktree-specific vars (setup.sh copies .env from main via post-checkout hook)
  local wt_env
  wt_env=$(env_file_for "$wt_dir")
  write_env_vars "$wt_env" "$wt_id" "$port"
  echo -e "${GREEN}Updated POSTGRES_*, PORT, NEXT_PUBLIC_SITE_URL in .env${NC}"

  # Track branch in Graphite if --branch was provided and gt is available
  if [[ -n "$branch" ]] && command -v gt &>/dev/null; then
    echo ""
    echo -e "${BOLD}Tracking branch in Graphite...${NC}"
    local pr_base=""
    if command -v gh &>/dev/null; then
      pr_base=$(gh pr view "$branch" --json baseRefName --jq '.baseRefName' 2>/dev/null) || true
    fi
    if [[ -n "${pr_base:-}" ]]; then
      echo -e "  PR targets: ${pr_base}"
      (cd "$wt_dir" && git rebase "origin/${pr_base}" 2>/dev/null; gt branch track --force --parent "$pr_base" 2>/dev/null) \
        && echo -e "${GREEN}Tracked in Graphite (parent: ${pr_base})${NC}" \
        || echo -e "${YELLOW}Graphite tracking skipped${NC}"
    else
      (cd "$wt_dir" && gt branch track --force 2>/dev/null) \
        && echo -e "${GREEN}Tracked in Graphite${NC}" \
        || echo -e "${YELLOW}Graphite tracking skipped (no PR found, used nearest ancestor)${NC}"
    fi
  fi

  echo ""
  echo -e "${BOLD}Ready!${NC} cd $wt_dir"
}

cmd_checkout() {
  if ! command -v gh &>/dev/null; then
    echo -e "${RED}gh CLI is required. Install it first.${NC}"
    exit 1
  fi

  if ! command -v fzf &>/dev/null; then
    echo -e "${RED}fzf is required for interactive selection.${NC}"
    exit 1
  fi

  # Verify gh authentication
  gh api user --jq '.login' 2>/dev/null > /dev/null || {
    echo -e "${RED}Not authenticated with gh. Run 'gh auth login' first.${NC}"
    exit 1
  }

  echo -e "${BOLD}Fetching your remote branches...${NC}"
  git fetch --prune origin > /dev/null 2>&1

  # Get branches already checked out in worktrees
  local wt_branches
  wt_branches=$(git worktree list --porcelain | awk '/^branch / { sub(/^refs\/heads\//, "", $2); print $2 }')

  # List remote branches excluding those already in a worktree and HEAD
  local branches
  branches=$(
    git for-each-ref \
      --sort=-committerdate \
      --format='%(refname:short)|%(authorname)|%(authoremail)|%(committerdate:relative)|%(subject)' \
      refs/remotes/origin/ \
    | grep -v '^origin/HEAD' \
    | while IFS='|' read -r ref _author _email date subject; do
        local branch="${ref#origin/}"

        # Skip branches already in a worktree
        if echo "$wt_branches" | grep -qx "$branch"; then
          continue
        fi

        echo "${branch}|${date}|${subject}"
      done
  )

  # Filter to branches owned by the GitHub user using gh pr list
  local pr_branches
  pr_branches=$(gh pr list --author "@me" --state all --limit 100 --json headRefName --jq '.[].headRefName' 2>/dev/null)

  # Build the selectable list: branches that have a PR by this user
  local selectable
  selectable=$(
    echo "$branches" | while IFS='|' read -r branch date subject; do
      [[ -z "$branch" ]] && continue
      if echo "$pr_branches" | grep -qx "$branch"; then
        printf "%-40s %-20s %s\n" "$branch" "$date" "$subject"
      fi
    done
  )

  if [[ -z "$selectable" ]]; then
    echo -e "${YELLOW}No remote branches found with your PRs that aren't already worktrees.${NC}"
    exit 0
  fi

  # Let user pick
  local selection
  selection=$(echo "$selectable" | fzf --prompt="Check out branch: " --header="BRANCH                                   UPDATED              SUBJECT") || exit 0

  local branch
  branch=$(echo "$selection" | awk '{print $1}')

  if [[ -z "$branch" ]]; then
    echo "No branch selected."
    exit 0
  fi

  echo ""
  cmd_create --branch "$branch"
}

cmd_remove() {
  local arg="${1:-}"
  local n=""

  if [[ -z "$arg" ]]; then
    # Interactive picker
    if ! command -v fzf &>/dev/null; then
      echo -e "${RED}fzf is required for interactive selection, or pass a worktree number.${NC}"
      exit 1
    fi

    local main_dir
    main_dir=$(main_worktree_dir)
    local repo
    repo=$(repo_name)

    # Build a list of wtN worktrees for the picker
    git worktree list --porcelain | awk '
      /^worktree / { wt = $2 }
      /^branch /   { branch = $2; sub(/^refs\/heads\//, "", branch) }
      /^$/ {
        if (wt != "") print wt "|" branch
        wt = ""; branch = ""
      }
    ' | while IFS='|' read -r wt_path branch; do
      local dir_name
      dir_name=$(basename "$wt_path")
      # Only show wtN worktrees, not main
      if [[ "$dir_name" =~ ^${repo}-wt([0-9]+)$ ]]; then
        local wt_num="${BASH_REMATCH[1]}"
        printf "wt%-4s %-40s %s\n" "$wt_num" "$wt_path" "${branch:-(detached)}"
      fi
    done > /tmp/wt_remove_list.$$ || true

    if [[ ! -s /tmp/wt_remove_list.$$ ]]; then
      echo -e "${YELLOW}No worktrees to remove.${NC}"
      rm -f /tmp/wt_remove_list.$$
      exit 0
    fi

    local selection
    selection=$(cat /tmp/wt_remove_list.$$ | fzf --prompt="Remove worktree: " --header="ID     DIRECTORY                                 BRANCH") || {
      rm -f /tmp/wt_remove_list.$$
      exit 0
    }
    rm -f /tmp/wt_remove_list.$$

    n=$(echo "$selection" | awk '{print $1}' | sed 's/^wt//')
  else
    # Parse arg: accept "3" or "wt3"
    n="${arg#wt}"
    if ! [[ "$n" =~ ^[0-9]+$ ]]; then
      echo -e "${RED}Invalid worktree identifier: ${arg}${NC}"
      echo "Usage: wt remove [N|wtN]"
      exit 1
    fi
  fi

  local wt_id="wt${n}"
  local wt_dir
  wt_dir=$(worktree_dir_for_number "$n")

  echo -e "${BOLD}Removing worktree ${wt_id}${NC}"
  echo ""

  # Remove git worktree
  if git worktree list --porcelain | grep -q "^worktree ${wt_dir}$"; then
    echo -e "${YELLOW}Removing worktree:${NC} $wt_dir"
    git worktree remove "$wt_dir" --force
  else
    echo "Worktree directory not found in git, skipping git worktree remove."
    if [[ -d "$wt_dir" ]]; then
      rm -rf "$wt_dir"
    fi
  fi

  # Drop databases and user
  echo ""
  pg_drop_worktree_dbs "$wt_id"

  echo ""
  echo -e "${BOLD}Done.${NC}"
}

cmd_list() {
  local main_dir
  main_dir=$(main_worktree_dir)
  local repo
  repo=$(repo_name)

  printf "${BOLD}%-6s %-40s %-25s %-8s %-10s %s${NC}\n" "ID" "DIRECTORY" "BRANCH" "PORT" "STATUS" "COMMIT"

  git worktree list --porcelain | awk -v main_dir="$main_dir" -v repo="$repo" '
    /^worktree / { wt = $2 }
    /^HEAD /     { commit = substr($2, 1, 7) }
    /^branch /   { branch = $2; sub(/^refs\/heads\//, "", branch) }
    /^detached/  { branch = "(detached)" }
    /^$/ {
      if (wt != "") {
        # Check for dirty state
        cmd = "git -C " wt " status --porcelain 2>/dev/null | head -1"
        cmd | getline dirty
        close(cmd)
        status = (dirty != "") ? "*" : ""

        dir_name = wt
        sub(/.*\//, "", dir_name)

        if (wt == main_dir) {
          id = "main"
          port = "3000"
        } else {
          # Check if this is a wtN-style worktree
          pattern = repo "-wt"
          if (index(dir_name, pattern) == 1) {
            num = substr(dir_name, length(pattern) + 1)
            if (num ~ /^[0-9]+$/) {
              id = "wt" num
              port = 3000 + num
            } else {
              id = "?"
              port = "?"
            }
          } else {
            id = "old"
            port = "?"
          }
        }

        printf "%-6s %-40s %-25s %-8s %-10s %s\n", id, wt, branch, port, status, commit
      }
      wt = ""; commit = ""; branch = ""; dirty = ""
    }
  '
}

cmd_switch() {
  if ! command -v fzf &>/dev/null; then
    echo "fzf is required for interactive switching. Install it or use 'cd' directly."
    echo ""
    cmd_list
    exit 1
  fi

  local selection
  selection=$(git worktree list | fzf --prompt="Switch to worktree: " | awk '{print $1}')

  if [[ -n "$selection" ]]; then
    echo "$selection"
    cd "$selection" || exit 1
  fi
}

# --- Main dispatch ---

# Ensure we're in a git repo
if ! git rev-parse --git-dir > /dev/null 2>&1; then
  echo "Error: not in a git repository."
  exit 1
fi

[[ $# -lt 1 ]] && { cmd_help; exit 0; }

command="$1"
shift

case "$command" in
  create)   cmd_create "$@" ;;
  checkout) cmd_checkout ;;
  remove)   cmd_remove "$@" ;;
  list)     cmd_list ;;
  switch)   cmd_switch ;;
  help)     cmd_help ;;
  *)        echo "Unknown command: $command"; usage ;;
esac
