#!/usr/bin/env bash
# wt â€” Git worktree manager with per-worktree database isolation.
#
# Usage:
#   wt create <branch>         Create worktree + branch, clone DBs, set up .env
#   wt checkout                Pick a remote branch (yours) to check out as a worktree
#   wt remove <branch>         Remove worktree + drop DBs
#   wt list                    List all worktrees with status
#   wt switch                  Interactive worktree switcher (requires fzf)

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")" && pwd)"
LIB_DIR="$(cd "$SCRIPT_DIR/../lib" && pwd)"

# shellcheck source=../lib/postgres.sh
source "$LIB_DIR/postgres.sh"

# --------------------------------------------------------------------------
# Helpers
# --------------------------------------------------------------------------

# Get the main worktree directory for the current repo
main_worktree_dir() {
  git worktree list --porcelain | grep '^worktree ' | head -1 | sed 's/^worktree //'
}

# Get the repo base name (directory name of the main worktree)
repo_name() {
  basename "$(main_worktree_dir)"
}

# Compute the worktree directory path: sibling of main worktree, named <repo>-<branch>
worktree_dir_for() {
  local branch="$1"
  local sanitized
  sanitized=$(pg_sanitize_branch_name "$branch")
  local main_dir
  main_dir=$(main_worktree_dir)
  echo "$(dirname "$main_dir")/$(repo_name)-${sanitized}"
}

# Get the .env file path within a worktree
env_file_for() {
  echo "$1/apps/platform/.env"
}

# Update POSTGRES_* vars in a .env file with per-worktree values.
# Preserves all non-POSTGRES lines. If no .env exists, creates one from the env vars alone.
write_env_vars() {
  local env_file="$1"
  local branch="$2"
  local env_vars
  env_vars=$(pg_generate_env_urls "$branch")

  if [[ -f "$env_file" ]]; then
    # Remove existing POSTGRES_* lines, then append new ones
    local tmp
    tmp=$(mktemp)
    grep -v '^POSTGRES_' "$env_file" > "$tmp" || true
    # Remove trailing blank lines
    sed -i -e :a -e '/^\n*$/{$d;N;ba' -e '}' "$tmp"
    echo "" >> "$tmp"
    echo "$env_vars" >> "$tmp"
    mv "$tmp" "$env_file"
  else
    mkdir -p "$(dirname "$env_file")"
    echo "$env_vars" > "$env_file"
  fi
}

# --------------------------------------------------------------------------
# Colors
# --------------------------------------------------------------------------

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BOLD='\033[1m'
NC='\033[0m'

# --------------------------------------------------------------------------
# Commands
# --------------------------------------------------------------------------

usage() {
  cat <<EOF
Usage: wt <command> [args]

Commands:
  create <branch>         Create worktree, clone DBs from main, wire .env
  checkout                Pick a remote branch (yours) to check out as a worktree
  remove <branch>         Remove worktree and drop DBs
  list                    List all worktrees with branch and status
  switch                  Interactive worktree switcher (requires fzf)
EOF
  exit 1
}

cmd_create() {
  local branch="${1:?Error: branch name required}"
  local wt_dir
  wt_dir=$(worktree_dir_for "$branch")
  local main_dir
  main_dir=$(main_worktree_dir)

  if [[ -d "$wt_dir" ]]; then
    echo -e "${RED}Worktree already exists:${NC} $wt_dir"
    exit 1
  fi

  echo -e "${BOLD}Creating worktree for '${branch}'${NC}"
  echo ""

  # Create git worktree with a new branch
  echo -e "${GREEN}Git worktree:${NC} $wt_dir"
  git worktree add "$wt_dir" -b "$branch" 2>/dev/null \
    || git worktree add "$wt_dir" "$branch"

  # Clone databases from main
  echo ""
  pg_clone_worktree_dbs "$branch"

  # Copy .env from main worktree and update POSTGRES vars
  local main_env
  main_env=$(env_file_for "$main_dir")
  local wt_env
  wt_env=$(env_file_for "$wt_dir")

  if [[ -f "$main_env" ]]; then
    mkdir -p "$(dirname "$wt_env")"
    cp "$main_env" "$wt_env"
    echo ""
    echo -e "${GREEN}Copied .env from main worktree${NC}"
  fi

  write_env_vars "$wt_env" "$branch"
  echo -e "${GREEN}Updated POSTGRES_* vars in .env${NC}"

  # Run project setup if available
  if [[ -f "$wt_dir/scripts/setup.sh" ]]; then
    echo ""
    echo -e "${BOLD}Running project setup...${NC}"
    (cd "$wt_dir" && ROOT_WORKTREE_PATH="$main_dir" bash scripts/setup.sh)
  fi

  echo ""
  echo -e "${BOLD}Ready!${NC} cd $wt_dir"
}

cmd_checkout() {
  if ! command -v gh &>/dev/null; then
    echo -e "${RED}gh CLI is required. Install it first.${NC}"
    exit 1
  fi

  if ! command -v fzf &>/dev/null; then
    echo -e "${RED}fzf is required for interactive selection.${NC}"
    exit 1
  fi

  # Get current GitHub username
  local gh_user
  gh_user=$(gh api user --jq '.login' 2>/dev/null) || {
    echo -e "${RED}Not authenticated with gh. Run 'gh auth login' first.${NC}"
    exit 1
  }

  echo -e "${BOLD}Fetching your remote branches...${NC}"
  git fetch --prune origin > /dev/null 2>&1

  # Get branches already checked out in worktrees
  local wt_branches
  wt_branches=$(git worktree list --porcelain | awk '/^branch / { sub(/^refs\/heads\//, "", $2); print $2 }')

  # List remote branches where the latest commit is authored by the current user,
  # excluding branches already in a worktree and HEAD
  local branches
  branches=$(
    git for-each-ref \
      --sort=-committerdate \
      --format='%(refname:short)|%(authorname)|%(authoremail)|%(committerdate:relative)|%(subject)' \
      refs/remotes/origin/ \
    | grep -v '^origin/HEAD' \
    | while IFS='|' read -r ref author email date subject; do
        local branch="${ref#origin/}"

        # Skip branches already in a worktree
        if echo "$wt_branches" | grep -qx "$branch"; then
          continue
        fi

        # Check if the branch's PR author matches (via gh) or the commit author matches
        # Use email matching against gh user
        echo "${branch}|${date}|${subject}"
      done
  )

  # Filter to branches owned by the GitHub user using gh pr list
  local pr_branches
  pr_branches=$(gh pr list --author "@me" --state all --limit 100 --json headRefName --jq '.[].headRefName' 2>/dev/null)

  # Build the selectable list: branches that have a PR by this user
  local selectable
  selectable=$(
    echo "$branches" | while IFS='|' read -r branch date subject; do
      [[ -z "$branch" ]] && continue
      if echo "$pr_branches" | grep -qx "$branch"; then
        printf "%-40s %-20s %s\n" "$branch" "$date" "$subject"
      fi
    done
  )

  if [[ -z "$selectable" ]]; then
    echo -e "${YELLOW}No remote branches found with your PRs that aren't already worktrees.${NC}"
    exit 0
  fi

  # Let user pick
  local selection
  selection=$(echo "$selectable" | fzf --prompt="Check out branch: " --header="BRANCH                                   UPDATED              SUBJECT") || exit 0

  local branch
  branch=$(echo "$selection" | awk '{print $1}')

  if [[ -z "$branch" ]]; then
    echo "No branch selected."
    exit 0
  fi

  echo ""
  # Reuse cmd_create which handles: worktree add, db clone, .env, setup
  cmd_create "$branch"
}

cmd_remove() {
  local branch="${1:?Error: branch name required}"
  local sanitized
  sanitized=$(pg_sanitize_branch_name "$branch")
  local wt_dir
  wt_dir=$(worktree_dir_for "$branch")

  if [[ "$sanitized" == "main" ]]; then
    echo -e "${RED}Cannot remove the main worktree.${NC}"
    exit 1
  fi

  echo -e "${BOLD}Removing worktree for '${branch}'${NC}"
  echo ""

  # Remove git worktree
  if git worktree list --porcelain | grep -q "^worktree ${wt_dir}$"; then
    echo -e "${YELLOW}Removing worktree:${NC} $wt_dir"
    git worktree remove "$wt_dir" --force
  else
    echo "Worktree directory not found, skipping git worktree remove."
    # Clean up directory if it exists but isn't a registered worktree
    if [[ -d "$wt_dir" ]]; then
      rm -rf "$wt_dir"
    fi
  fi

  # Drop databases
  echo ""
  pg_drop_worktree_dbs "$branch"

  # Delete the branch if it's fully merged
  if git branch --list "$branch" | grep -q "$branch"; then
    if git branch --merged main | grep -q "$branch"; then
      git branch -d "$branch" 2>/dev/null && echo -e "${GREEN}Deleted merged branch '${branch}'${NC}"
    else
      echo -e "${YELLOW}Branch '${branch}' is not merged into main, keeping it.${NC}"
    fi
  fi

  echo ""
  echo -e "${BOLD}Done.${NC}"
}

cmd_list() {
  local main_dir
  main_dir=$(main_worktree_dir)

  printf "${BOLD}%-40s %-25s %-10s %s${NC}\n" "DIRECTORY" "BRANCH" "STATUS" "COMMIT"

  git worktree list --porcelain | awk '
    /^worktree / { wt = $2 }
    /^HEAD /     { commit = substr($2, 1, 7) }
    /^branch /   { branch = $2; sub(/^refs\/heads\//, "", branch) }
    /^$/ {
      if (wt != "") {
        # Check for dirty state
        cmd = "git -C " wt " status --porcelain 2>/dev/null | head -1"
        cmd | getline dirty
        close(cmd)
        status = (dirty != "") ? "*" : ""
        printf "%-40s %-25s %-10s %s\n", wt, branch, status, commit
      }
      wt = ""; commit = ""; branch = ""; dirty = ""
    }
  '
}

cmd_switch() {
  if ! command -v fzf &>/dev/null; then
    echo "fzf is required for interactive switching. Install it or use 'cd' directly."
    echo ""
    cmd_list
    exit 1
  fi

  local selection
  selection=$(git worktree list | fzf --prompt="Switch to worktree: " | awk '{print $1}')

  if [[ -n "$selection" ]]; then
    echo "$selection"
    cd "$selection" || exit 1
  fi
}

# --- Main dispatch ---

# Ensure we're in a git repo
if ! git rev-parse --git-dir > /dev/null 2>&1; then
  echo "Error: not in a git repository."
  exit 1
fi

[[ $# -lt 1 ]] && usage

command="$1"
shift

case "$command" in
  create)   cmd_create "$@" ;;
  checkout) cmd_checkout ;;
  remove)   cmd_remove "$@" ;;
  list)     cmd_list ;;
  switch)   cmd_switch ;;
  *)        echo "Unknown command: $command"; usage ;;
esac
